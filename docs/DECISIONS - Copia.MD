# DECISIONS ‚Äî Registro de Decis√µes T√©cnicas

**Status:** Ativo  
**√öltima atualiza√ß√£o:** 2026-01-20  
**Natureza:** Documento can√¥nico de hist√≥rico decis√≥rio

Este documento registra **decis√µes t√©cnicas efetivamente tomadas**, seu
contexto, motiva√ß√£o e impacto no projeto.

Ele complementa os ADRs:
- ADRs definem **arquitetura e princ√≠pios**
- DECISIONS registram **decis√µes operacionais e evolutivas**

Este documento existe para **evitar regress√µes, retrabalho e rediscuss√µes**.

---

## 1. Regras de Uso deste Documento

- Decis√µes aqui registradas **n√£o s√£o reabertas**
- Mudan√ßas de dire√ß√£o exigem **nova entrada**
- ADRs aprovados **n√£o s√£o reescritos**
- DECISIONS podem complementar ADRs sem substitu√≠-los

---

## 2. ADRs Aprovados (Refer√™ncia)

### ADR-001 ‚Äî Qualidade da Transcri√ß√£o em PT-BR

- **Status:** Aprovado  
- **Data:** 2026-01-19  
- **Escopo:** ASR + P√≥s-processamento  
- **Refer√™ncia:** `docs/ADR-001-transcricao.md`

**Resumo:**
- Identifica√ß√£o de falhas de inteligibilidade e alucina√ß√£o
- Necessidade de p√≥s-processamento robusto
- Fundamenta√ß√£o para cria√ß√£o de refinadores determin√≠sticos

---

### ADR-002 ‚Äî Estrutura de Resumo / Ata Corporativa

- **Status:** Aprovado  
- **Data:** 2026-01-19  
- **Escopo:** LLM + Pre√¢mbulos  
- **Refer√™ncia:** `docs/ADR-002 ‚Äî Estrutura de ResumoAta Corporativa.md`

**Status de Implementa√ß√£o:**
- Pipeline m√≠nimo implementado (`corporate_minutes.py`)
- Gate de seguran√ßa para transcri√ß√£o vazia validado
- Testes manuais executados com sucesso (`fake_llm`)
- Ata **n√£o √© gerada** sem transcri√ß√£o v√°lida

---

### ADR-003 ‚Äî Chunking Sem√¢ntico para LLM

- **Status:** Aprovado  
- **Data:** 2026-01-19  
- **Escopo:** Textos longos / LLM  
- **Refer√™ncia:** `docs/ADR-003 ‚Äî Chunking Sem√¢ntico para LLM.md`

**Objetivo:**
- Evitar perda de contexto
- Reduzir alucina√ß√£o em textos longos

---

## 3. Decis√µes Arquiteturais e Operacionais

### Uso de LLM local para sumariza√ß√£o (Ollama)

- **Data:** 2026-01-20

Ap√≥s an√°lise de reposit√≥rios p√∫blicos e modelos pagos,
foi adotado **LLM local via Ollama** para sumariza√ß√£o e gera√ß√£o de atas.

**Decis√£o:**
- Uso exclusivo para sa√≠das derivadas (ata / resumo)
- Nenhum c√≥digo externo reutilizado
- Implementa√ß√£o sem estado, sem hist√≥rico e sem infer√™ncia

**Motiva√ß√£o:**
- Eliminar custos vari√°veis
- Garantir previsibilidade
- Manter controle total do pipeline

---

### Ativa√ß√£o de limpeza leve de oralidade e repeti√ß√£o

- **Data:** 2026-01-20

Foi ativada limpeza **opt-in** de termos de oralidade e
repeti√ß√µes mec√¢nicas no p√≥s-processamento da transcri√ß√£o.

**Decis√£o:**
- Atua√ß√£o apenas sobre termos expl√≠citos
- Sem altera√ß√£o sem√¢ntica
- Totalmente configur√°vel e revers√≠vel via config

**Motiva√ß√£o:**
- Melhorar legibilidade da transcri√ß√£o
- Reduzir ru√≠do para gera√ß√£o de atas e resumos

---

### Engine de ASR com fallback expl√≠cito

- **Data:** 2026-01-20

Foi definida sele√ß√£o expl√≠cita de engine de ASR via configura√ß√£o.
Observa√ß√£o:
- No estado atual do projeto, Whisper local est√° ativo como engine efetiva.
- A op√ß√£o GPT-4o permanece desabilitada por decis√£o de custo.


**Decis√£o:**
- Whisper local como default operacional
- GPT-4o-mini-transcribe mantido como op√ß√£o futura
- Nenhum servi√ßo externo inicializado no import

**Motiva√ß√£o:**
- Evitar depend√™ncias obrigat√≥rias
- Garantir execu√ß√£o offline
- Prevenir falhas por configura√ß√£o incompleta

---

## 4. Avalia√ß√£o Geral da Arquitetura

- **Data:** 2026-01-19

Ap√≥s revis√£o completa da estrutura de diret√≥rios e do fluxo real
de execu√ß√£o, fica registrado que a arquitetura por camadas:

√°udio ‚Üí core (ASR) ‚Üí refiners ‚Üí transcri√ß√£o (fonte prim√°ria)
‚Üí summarizers (LLM) ‚Üí artefatos derivados

yaml
Copiar c√≥digo

est√° correta, consistente e alinhada com os ADRs aprovados.

Nenhuma viola√ß√£o de responsabilidade entre camadas foi identificada.

Este registro √© **informativo** e n√£o altera ADRs existentes.

---

## 5. Componentes Obsoletos / Fora do Pipeline Oficial

Os componentes abaixo permanecem no reposit√≥rio **apenas como refer√™ncia
hist√≥rica ou uso manual**, n√£o integrando o pipeline homologado.

### summarizer.py
- **Motivo:** gera√ß√£o manual de Markdown, sem LLM ou ADR-002
- **Status:** Obsoleto ‚Äî n√£o utilizar em produ√ß√£o

### gemma.py (modo CLI isolado)
- **Motivo:** ferramenta auxiliar para testes manuais
- **Status:** Fora do pipeline oficial

Esses arquivos **n√£o devem ser utilizados** por `app.py` nem por fluxos automatizados.

---

## 6. Projetos Externos Analisados (Refer√™ncia Hist√≥rica)

Os projetos abaixo foram analisados apenas como refer√™ncia conceitual
e **n√£o fazem parte da evolu√ß√£o ativa do projeto**:

- `meeting-summaries-main`
- `meeting_minutes_generator-main`

**Decis√£o:**
- Nenhum c√≥digo foi reutilizado
- Apenas ideias conceituais foram avaliadas
- N√£o entram mais na evolu√ß√£o do projeto

---

## 7. Regra Final

Este documento √© **fonte de verdade hist√≥rica**.

Antes de qualquer altera√ß√£o funcional relevante:
1. Revisar este arquivo
2. Verificar se a decis√£o j√° existe
3. Criar nova entrada **apenas se necess√°rio**

Rediscuss√£o sem revis√£o hist√≥rica √© considerada **falha de processo**.

### Defini√ß√£o expl√≠cita de sample rate para grava√ß√£o de √°udio (Windows)

- **Data:** 2026-01-20

Durante testes de grava√ß√£o no Windows utilizando `sounddevice` + PortAudio,
foi identificado erro recorrente:

PortAudioError: Invalid sample rate [PaErrorCode -9997]


Ap√≥s inspe√ß√£o direta do dispositivo de entrada via Python:

```python
import sounddevice as sd
sd.query_devices(9, 'input')['default_samplerate']

Decis√£o:

O sample rate de grava√ß√£o foi fixado explicitamente em 48000 Hz

A grava√ß√£o deve sempre usar o sample rate nativo do dispositivo

Evita falhas de inicializa√ß√£o de InputStream no Windows (WASAPI)

Motiva√ß√£o:

PortAudio em modo compartilhado (WASAPI) exige compatibilidade exata

Sample rates divergentes causam falha imediata de stream

48000 Hz √© o padr√£o mais comum em microfones Windows modernos

Essa decis√£o √© considerada obrigat√≥ria para execu√ß√£o est√°vel do projeto em Windows.

### Substitui√ß√£o de sounddevice por PyAudio para grava√ß√£o (Windows)

- **Data:** 2026-01-20

Ap√≥s m√∫ltiplos testes pr√°ticos no Windows, foi constatado que a biblioteca
`sounddevice` apresenta instabilidade estrutural com PortAudio nos backends
WDM / WASAPI, gerando erros recorrentes:

- PaErrorCode -9996 (Invalid device)
- PaErrorCode -9997 (Invalid sample rate)
- PaErrorCode -9999 (Unanticipated host error)

Mesmo com configura√ß√£o correta de device e sample rate, os erros persistem.

**Decis√£o:**
- Substituir definitivamente `sounddevice` por `PyAudio` na camada de grava√ß√£o
- Manter a interface p√∫blica (`Recorder.start()` / `stop()`)
- N√£o alterar app.py nem pipeline de transcri√ß√£o

**Refer√™ncia t√©cnica:**
- Projeto `whisper_mic`, amplamente utilizado e validado em Windows

**Motiva√ß√£o:**
- Estabilidade real em ambiente Windows
- Controle expl√≠cito de buffer e stream
- Elimina√ß√£o de falhas no n√≠vel do driver

Essa decis√£o √© considerada **definitiva para grava√ß√£o de microfone no Windows**.
### Extens√£o do Recorder com controle de estado (pause / resume)

- **Data:** 2026-01-20

O m√≥dulo `recorder.py` foi estendido para suportar
controle expl√≠cito de estado de grava√ß√£o:

- `start()` ‚Üí inicia grava√ß√£o
- `pause()` ‚Üí pausa captura de √°udio
- `resume()` ‚Üí retoma captura
- `stop()` ‚Üí finaliza e persiste o WAV

A extens√£o foi implementada **sem quebra de compatibilidade**,
mantendo a interface p√∫blica j√° utilizada pelo `app.py`.

**Decis√£o t√©cnica associada:**
- Migra√ß√£o definitiva da captura de √°udio para PyAudio
- Uso de buffer manual inspirado no projeto `whisper_mic`

**Motiva√ß√£o:**
- Maior controle de UX
- Prepara√ß√£o para indicadores visuais (tempo, estado, VU meter)
- Estabilidade comprovada no Windows

Essa decis√£o n√£o altera o pipeline de transcri√ß√£o nem os refinadores.
### Separa√ß√£o da grava√ß√£o de √°udio do Streamlit (Windows)

**Data:** 2026-01-20

Ap√≥s m√∫ltiplos testes, foi constatado que a captura direta de microfone
via PortAudio (PyAudio / sounddevice) √© inst√°vel no Windows quando
executada dentro do runtime do Streamlit, resultando no erro recorrente:

`OSError: [Errno -9999] Unanticipated host error`

Mesmo com:
- device correto
- sample rate compat√≠vel
- implementa√ß√£o conforme boas pr√°ticas
- stream aberto fora de threads de aplica√ß√£o

o erro persistiu exclusivamente no contexto do Streamlit.

**Decis√£o:**
- Isolar a grava√ß√£o de √°udio em processo CLI separado
- Streamlit passa a apenas consumir arquivos WAV j√° gravados

**Motiva√ß√£o:**
- Estabilidade comprovada no Windows
- Elimina√ß√£o de conflitos de event loop e handles de √°udio
- Arquitetura mais previs√≠vel e sustent√°vel

Essa decis√£o √© considerada definitiva para ambientes Windows.
## 2026-01-20 ‚Äî Consolida√ß√£o de Refino de Transcri√ß√£o e UX no Windows

### Contexto
Durante a integra√ß√£o final entre CLI, Streamlit e pipeline de transcri√ß√£o,
foram identificadas limita√ß√µes estruturais no uso de PyAudio em conjunto
com Streamlit no Windows (PortAudio / WASAPI).

Al√©m disso, iniciou-se a fase de refino determin√≠stico da transcri√ß√£o,
com foco em qualidade textual, sem uso de LLM e sem violar a transcri√ß√£o
como fonte prim√°ria.

---

### Decis√µes Tomadas

#### 1. Grava√ß√£o de √°udio no Windows
- **Decis√£o:** Streamlit N√ÉO deve gravar √°udio diretamente no Windows.
- **Motivo:** Instabilidade recorrente do PyAudio/PortAudio em runtime Streamlit
  (erros -9996 e -9999).
- **Solu√ß√£o adotada:**  
  - Grava√ß√£o feita exclusivamente via CLI (`cli_local.py gravar`)
  - Streamlit consome apenas arquivos WAV j√° gravados
- **Status:** Homologado

#### 2. Separa√ß√£o clara de responsabilidades (UX)
- CLI:
  - grava √°udio
  - salva WAV confi√°vel
- Streamlit:
  - upload/consumo de WAV
  - transcri√ß√£o
  - refino
  - gera√ß√£o de ata/resumo
- **Status:** Homologado

---

### Refino de Transcri√ß√£o (Fase 1)

#### Refinadores implementados
- `refiners/orality.py`
  - Remo√ß√£o determin√≠stica de termos de oralidade configurados
  - Sem infer√™ncia sem√¢ntica
- `refiners/repetition.py`
  - Remo√ß√£o de repeti√ß√µes mec√¢nicas consecutivas
- `refiners/hallucination.py`
  - Detec√ß√£o e corte de alucina√ß√£o local e global (ADR-001)

Todos os refinadores:
- s√£o determin√≠sticos
- s√£o configur√°veis via `config/transcription.toml`
- n√£o utilizam LLM
- n√£o inventam conte√∫do

---

### Ajustes no Orquestrador
- `transcriber.py` passou a:
  - importar refinadores como m√≥dulos isolados
  - aplicar refinadores em pipeline previs√≠vel
  - manter API p√∫blica est√°vel (`transcribe_audio`)

---

### Status Geral
- Pipeline de grava√ß√£o (CLI): **Est√°vel**
- Pipeline de transcri√ß√£o: **Est√°vel e refinado**
- Streamlit: **Est√°vel (sem captura de √°udio)**
- Arquitetura: **Alinhada aos ADRs**
- Pr√≥xima fase: **Refino lexical e segmenta√ß√£o sint√°tica**
### Registro adicional ‚Äî √Åudio v√°lido com transcri√ß√£o final vazia (2026-01-20)

Durante teste de grava√ß√£o via CLI (`python cli_local.py gravar`), foi observado
o seguinte comportamento:

- O √°udio foi gravado corretamente (`.wav` gerado com conte√∫do aud√≠vel)
- O Whisper executou a transcri√ß√£o sem erro
- O arquivo `.txt` de sa√≠da foi gerado, por√©m com conte√∫do vazio

#### Interpreta√ß√£o t√©cnica
- O texto bruto gerado pelo ASR n√£o atingiu crit√©rios m√≠nimos de qualidade
  ap√≥s aplica√ß√£o dos refinadores ativos
- O refinador de alucina√ß√£o global classificou o conte√∫do como semanticamente inv√°lido
- O pipeline retornou string vazia de forma intencional

#### Status
- Comportamento esperado
- Nenhuma falha de grava√ß√£o
- Nenhum erro de execu√ß√£o
- Nenhuma corre√ß√£o emergencial necess√°ria

#### Observa√ß√£o
Este registro serve apenas para rastreabilidade do comportamento observado.
O evento refor√ßa a necessidade dos refinadores de corre√ß√£o lexical e segmenta√ß√£o
para reduzir falsos positivos de descarte.
### Diagn√≥stico ‚Äî Discrep√¢ncia entre √°udio monitorado e √°udio gravado (2026-01-20)

Foi identificado que o √°udio monitorado pelo usu√°rio n√£o corresponde
ao dispositivo de captura utilizado pelo PyAudio.

O √°udio percebido como "bom" prov√©m do dispositivo:
- Mixagem est√©reo (Realtek HD Audio Stereo input)

Enquanto a captura estava ocorrendo via:
- dispositivo padr√£o / mapeador gen√©rico

Decis√£o:
- Tornar expl√≠cito o uso de `input_device_index` no recorder
- Selecionar entre microfone dedicado ou mixagem est√©reo conforme o contexto
### Decis√£o ‚Äî Par√¢metros de captura de √°udio tornados configur√°veis (2026-01-20)

Par√¢metros cr√≠ticos de captura de √°udio (device index, sample rate e canais)
foram externalizados para configura√ß√£o (`transcription.toml`).

Motiva√ß√£o:
- variabilidade de dispositivos no Windows
- necessidade de alinhar captura com contexto de uso
- evitar hardcode fr√°gil no recorder

Escopo:
- altera√ß√£o m√≠nima
- sem impacto no fluxo CLI
- sem altera√ß√£o de arquitetura
## 2026-01-20 ‚Äî Consolida√ß√£o da captura de √°udio via FFmpeg no Windows

### Contexto
Durante a evolu√ß√£o do pipeline de grava√ß√£o e transcri√ß√£o, foi identificado
erro persistente (`Errno -9999 Unanticipated host error`) ao tentar capturar
√°udio via PyAudio/PortAudio no Windows, mesmo ap√≥s:

- configura√ß√£o expl√≠cita de dispositivo
- uso de sample rate nativo do hardware
- instrumenta√ß√£o com logging detalhado
- valida√ß√£o de m√∫ltiplos dispositivos de entrada

Foi confirmado que o projeto **j√° utilizava anteriormente FFmpeg para captura
de √°udio**, e que esta abordagem funcionava de forma est√°vel.

---

### Diagn√≥stico
- O erro `-9999` √© caracter√≠stico de limita√ß√µes do stack:
  - Windows
  - drivers Realtek / Intel Smart Sound
  - PortAudio
- O erro ocorre mesmo com dispositivos v√°lidos enumerados
- N√£o h√° corre√ß√£o confi√°vel via ajustes de c√≥digo no PyAudio oficial
- O problema n√£o est√° na l√≥gica do projeto, mas na camada de captura

---

### Decis√£o
- **Abandonar PyAudio como mecanismo de captura de √°udio no Windows**
- **Retomar e padronizar o uso de FFmpeg para grava√ß√£o via CLI**
- Manter todo o restante do pipeline inalterado:
  - transcriber
  - refinadores
  - Corre√ß√£o

  # Decis√µes de Arquitetura do Projeto

---

## DEC-2026-01-20 ‚Äî Robustez do pipeline de transcri√ß√£o (√°udio baixo, alucina√ß√£o e fallback)

### Contexto

Durante testes em ambiente Windows corporativo, o pipeline de transcri√ß√£o apresentou comportamentos intermitentes:

* √°udio capturado com n√≠vel baixo variando conforme driver/dispositivo;
* Whisper processando o √°udio integralmente, mas retornando sa√≠da posteriormente descartada;
* filtros de alucina√ß√£o e repeti√ß√£o atuando de forma destrutiva, zerando transcri√ß√µes v√°lidas.

Esses cen√°rios ocorreram principalmente em treinamentos institucionais, com fala padronizada e repetitiva.

### Problema

A arquitetura anterior permitia que refinadores:

* retornassem string vazia;
* causassem falha terminal (`RuntimeError`) mesmo ap√≥s transcri√ß√£o v√°lida;
* perdessem m√©tricas lexicais j√° calculadas, exigindo recomputa√ß√£o posterior.

Isso tornava o pipeline fr√°gil e sens√≠vel a varia√ß√µes de √°udio e heur√≠stica.

### Decis√£o

Foram adotadas as seguintes decis√µes arquiteturais:

1. **Transcri√ß√£o v√°lida nunca √© descartada**
   O Whisper √© tratado como fonte prim√°ria de verdade. Caso refinadores resultem em texto vazio, o sistema faz fallback autom√°tico para o texto bruto.

2. **Filtros tornam-se n√£o destrutivos**
   Refinadores (ex.: `hallucination.py`) passam a **marcar e sinalizar** alucina√ß√£o, em vez de zerar conte√∫do ou causar falha.

3. **Normaliza√ß√£o e toler√¢ncia a √°udio baixo**
   O pipeline passa a normalizar o √°udio antes da transcri√ß√£o e reduz a agressividade de limiares de sil√™ncio, tornando-o resiliente a varia√ß√µes de volume do sistema.

4. **Propaga√ß√£o de m√©tricas ao longo do pipeline**
   M√©tricas lexicais calculadas em refinadores iniciais s√£o preservadas e disponibilizadas a jusante (ex.: para `lexical.py`), evitando recomputa√ß√£o e perda de sinal.

5. **Interface CLI mantida est√°vel**
   Todos os ajustes foram feitos via configura√ß√£o e l√≥gica interna, sem introduzir novos par√¢metros de linha de comando.

### Consequ√™ncias

* Elimina√ß√£o definitiva do erro "Transcri√ß√£o vazia ap√≥s processamento" em cen√°rios com √°udio v√°lido.
* Pipeline mais robusto para reuni√µes e treinamentos corporativos.
* Base s√≥lida para an√°lises lexicais, scoring e chunking sem√¢ntico futuros.
* Maior rastreabilidade e auditabilidade das decis√µes do sistema.

### Status

Aceita e implementada.
# Decis√µes de Arquitetura do Projeto

---

## DEC-2026-01-20 ‚Äî Robustez do pipeline de transcri√ß√£o (√°udio baixo, alucina√ß√£o e fallback)

### Contexto

Durante testes em ambiente Windows corporativo, o pipeline de transcri√ß√£o apresentou comportamentos intermitentes:

* √°udio capturado com n√≠vel baixo variando conforme driver/dispositivo;
* Whisper processando o √°udio integralmente, mas retornando sa√≠da posteriormente descartada;
* filtros de alucina√ß√£o e repeti√ß√£o atuando de forma destrutiva, zerando transcri√ß√µes v√°lidas.

Esses cen√°rios ocorreram principalmente em treinamentos institucionais, com fala padronizada e repetitiva.

### Problema

A arquitetura anterior permitia que refinadores:

* retornassem string vazia;
* causassem falha terminal (`RuntimeError`) mesmo ap√≥s transcri√ß√£o v√°lida;
* perdessem m√©tricas lexicais j√° calculadas, exigindo recomputa√ß√£o posterior.

Isso tornava o pipeline fr√°gil e sens√≠vel a varia√ß√µes de √°udio e heur√≠stica.

### Decis√£o

Foram adotadas as seguintes decis√µes arquiteturais:

1. **Transcri√ß√£o v√°lida nunca √© descartada**
   O Whisper √© tratado como fonte prim√°ria de verdade. Caso refinadores resultem em texto vazio, o sistema faz fallback autom√°tico para o texto bruto.

2. **Filtros tornam-se n√£o destrutivos**
   Refinadores (ex.: `hallucination.py`) passam a **marcar e sinalizar** alucina√ß√£o, em vez de zerar conte√∫do ou causar falha.

3. **Normaliza√ß√£o e toler√¢ncia a √°udio baixo**
   O pipeline passa a normalizar o √°udio antes da transcri√ß√£o e reduz a agressividade de limiares de sil√™ncio, tornando-o resiliente a varia√ß√µes de volume do sistema.

4. **Propaga√ß√£o de m√©tricas ao longo do pipeline**
   M√©tricas lexicais calculadas em refinadores iniciais s√£o preservadas e disponibilizadas a jusante (ex.: para `lexical.py`), evitando recomputa√ß√£o e perda de sinal.

5. **Interface CLI mantida est√°vel**
   Todos os ajustes foram feitos via configura√ß√£o e l√≥gica interna, sem introduzir novos par√¢metros de linha de comando.

### Consequ√™ncias

* Elimina√ß√£o definitiva do erro "Transcri√ß√£o vazia ap√≥s processamento" em cen√°rios com √°udio v√°lido.
* Pipeline mais robusto para reuni√µes e treinamentos corporativos.
* Base s√≥lida para an√°lises lexicais, scoring e chunking sem√¢ntico futuros.
* Maior rastreabilidade e auditabilidade das decis√µes do sistema.

### Status

Aceita e implementada.

---

## DEC-2026-01-20 ‚Äî Alinhamento de imports √† estrutura real do projeto

### Contexto

Durante a consolida√ß√£o do pipeline de transcri√ß√£o, ocorreram erros de importa√ß√£o (`ModuleNotFoundError` e `ImportError`) ap√≥s melhorias arquiteturais. Esses erros surgiram porque alguns trechos de c√≥digo passaram a assumir uma estrutura de pacote (`transcription.*`) que **n√£o corresponde √† estrutura real do projeto em disco**.

A estrutura efetiva do projeto utiliza diret√≥rios l√≥gicos (`core/`, `refiners/`) no mesmo n√≠vel dos scripts execut√°veis, sem empacotamento formal.

### Problema

* Imports apontavam para m√≥dulos inexistentes (`transcription.*`).
* Fun√ß√µes eram importadas com nomes n√£o expostos pelo m√≥dulo real (`transcribe_audio` vs. `whisper_transcribe`).
* O erro n√£o era de depend√™ncia, mas de **contrato e topologia de c√≥digo**.

### Decis√£o

Foram adotadas as seguintes decis√µes:

1. **Respeitar a estrutura real do projeto**
   Os imports devem refletir exatamente os diret√≥rios existentes (`core`, `refiners`), sem criar pacotes conceituais n√£o implementados.

2. **Manter o core est√°vel**
   O m√≥dulo `core/whisper_core.py` n√£o foi alterado. Ele exp√µe fun√ß√µes espec√≠ficas (`whisper_transcribe`) e retorna estruturas de dados claras.

3. **Orquestra√ß√£o adapta, core n√£o**
   O script `transcribe_file.py` √© respons√°vel por adaptar chamadas e extrair o texto bruto do resultado retornado pelo core.

4. **Evitar fun√ß√µes gen√©ricas fict√≠cias**
   Fun√ß√µes como `transcribe_audio` n√£o devem ser assumidas se n√£o fazem parte do contrato expl√≠cito do m√≥dulo.

### Consequ√™ncias

* Elimina√ß√£o definitiva de erros de importa√ß√£o em execu√ß√£o via CLI.
* Maior clareza sobre responsabilidades entre core, orquestra√ß√£o e refinadores.
* Base mais segura para futuras refatora√ß√µes (empacotamento formal poder√° ser feito de forma planejada).

### Status

Aceita e registrada.
üß† FLUXO FINAL (PARA FIXAR)

transcribe_file.py

chama ‚Üí whisper_transcribe(...)

recebe ‚Üí dict

extrai ‚Üí result["text"]

passa raw_text para:

orality

repetition

hallucination

lexical (depois)

üëâ Esse √© o contrato correto do pipeline.

# Integra√ß√£o com Streamlit

## Objetivo

Este documento registra a decis√£o e o padr√£o arquitetural para **reutilizar o Streamlit** como camada de interface do sistema de grava√ß√£o, transcri√ß√£o e refinamento textual, **sem comprometer a robustez do pipeline**.

---

## Contexto

Em vers√µes anteriores do projeto, o uso do Streamlit apresentou instabilidade devido a:

* pipeline de transcri√ß√£o fr√°gil;
* imports inconsistentes;
* refinadores destrutivos que podiam zerar a transcri√ß√£o;
* mistura de l√≥gica de neg√≥cio com l√≥gica de interface.

Ap√≥s a consolida√ß√£o do pipeline (core + refiners + orquestrador) e a corre√ß√£o dos fluxos de sa√≠da, o projeto atingiu maturidade suficiente para **reintroduzir o Streamlit de forma segura**.

---

## Decis√£o

O Streamlit ser√° utilizado **exclusivamente como camada de interface (UI)**, respeitando os seguintes princ√≠pios:

1. **Separa√ß√£o total de responsabilidades**

   * Streamlit n√£o cont√©m l√≥gica de transcri√ß√£o.
   * Streamlit n√£o importa Whisper nem refinadores diretamente.
   * Toda l√≥gica reside no pipeline CLI / Python.

2. **Pipeline como fonte de verdade**

   * O fluxo principal √© execut√°vel via CLI (`cli_local.py`).
   * A UI apenas dispara a√ß√µes e exibe resultados.

3. **Resili√™ncia da aplica√ß√£o**

   * Se o Streamlit falhar, o pipeline continua funcional.
   * Erros de processamento n√£o devem derrubar a interface.

---

## Arquitetura Alvo

```
Streamlit (UI)
   ‚Üì
Disparo de a√ß√£o (fun√ß√£o ou subprocess)
   ‚Üì
transcribe_file.py (orquestrador)
   ‚Üì
core/whisper_core.py
   ‚Üì
refiners/*
   ‚Üì
output/
```

### Diret√≥rios de sa√≠da

* `output/audio/` ‚Üí arquivos WAV
* `output/transcripts/` ‚Üí transcri√ß√µes textuais
* `output/summaries/` ‚Üí resumos
* `output/md/` ‚Üí vers√µes em Markdown

---

## O que o Streamlit PODE fazer

* Upload de arquivos de √°udio
* Inser√ß√£o de links (ex.: YouTube)
* Disparo da transcri√ß√£o
* Leitura e exibi√ß√£o dos arquivos gerados em `output/`
* Visualiza√ß√£o de logs e status

---

## O que o Streamlit N√ÉO deve fazer

* Importar Whisper diretamente
* Manipular √°udio em baixo n√≠vel
* Decidir regras de refinamento
* Alterar estrutura de pastas
* Substituir o pipeline CLI

Essas restri√ß√µes evitam:

* travamentos da UI;
* estados inconsistentes;
* bugs dif√≠ceis de rastrear;
* regress√µes arquiteturais.

---

## Estrat√©gias de Integra√ß√£o

### Op√ß√£o A ‚Äî Chamada direta de fun√ß√£o (recomendada inicialmente)

* Streamlit importa uma fun√ß√£o de alto n√≠vel do pipeline.
* Execu√ß√£o s√≠ncrona, mais simples de debugar.

### Op√ß√£o B ‚Äî Chamada via subprocess

* Streamlit executa `cli_local.py`.
* Maior isolamento.
* √ötil para ambientes mais restritivos.

Ambas s√£o compat√≠veis com o padr√£o adotado.

---

## Benef√≠cios da Abordagem

* Interface desacoplada
* Pipeline test√°vel independentemente
* Facilidade de manuten√ß√£o
* Base s√≥lida para evolu√ß√£o futura

---

## Status

* **Decis√£o aceita**
* **Integra√ß√£o permitida**
* **Pipeline pronto para uso com Streamlit**

---

## Observa√ß√£o Final

O Streamlit passa a ser um **componente descart√°vel** do sistema. O valor do projeto reside no pipeline de transcri√ß√£o e refinamento, n√£o na interface.

  Resolu√ß√£o de paths em scripts de tests/

Data: 2026-01-20

Durante a execu√ß√£o de scripts localizados no diret√≥rio tests/, foi identificado erro recorrente de execu√ß√£o ao chamar o cli_local.py por caminho relativo, resultando em:

can't open file '...\\tests\\cli_local.py'


Decis√£o:

Scripts localizados em tests/ devem sempre resolver caminhos com base na raiz do projeto, utilizando Path(__file__).

√â proibido assumir que a execu√ß√£o ocorrer√° a partir da raiz (cwd vari√°vel).

O cli_local.py √© considerado ancorado na raiz do projeto e deve ser referenciado por path absoluto derivado.

Padr√£o obrigat√≥rio:

from pathlib import Path

CURRENT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = CURRENT_DIR.parent
CLI_PATH = PROJECT_ROOT / "cli_local.py"


Motiva√ß√£o:

Evitar falhas por execu√ß√£o fora da raiz

Garantir reprodutibilidade em Windows, venv, CI e futuras integra√ß√µes (ex.: Streamlit)

Manter a arquitetura CLI como fonte de verdade, sem mover arquivos

Status:
‚úîÔ∏è Decis√£o aceita
‚úîÔ∏è Aplicada no download_and_transcribe_youtube.py
‚úîÔ∏è N√£o altera arquitetura nem contratos existentes

‚úÖ Decis√£o que est√° CORRETA

‚ÄúScripts em tests/ devem sempre resolver paths via Path(__file__)‚Äù

Ela est√° 100% alinhada com o projeto.

‚ùå O que ainda est√° violando a decis√£o

Existe alguma chamada residual (provavelmente no cli_local.py antigo ou em vers√£o em cache) que ainda faz:

chamada direta a transcribe_file.py sem path absoluto


C:\gravador_transcritor
‚îú‚îÄ‚îÄ cli_local.py
‚îú‚îÄ‚îÄ transcribe_file.py
‚îú‚îÄ‚îÄ transcriber.py
‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ recorder.py
‚îú‚îÄ‚îÄ config\
‚îÇ   ‚îî‚îÄ‚îÄ transcription.toml
‚îú‚îÄ‚îÄ core\
‚îÇ   ‚îî‚îÄ‚îÄ whisper_core.py
‚îú‚îÄ‚îÄ refiners\
‚îÇ   ‚îú‚îÄ‚îÄ orality.py
‚îÇ   ‚îú‚îÄ‚îÄ repetition.py
‚îÇ   ‚îú‚îÄ‚îÄ hallucination.py
‚îÇ   ‚îî‚îÄ‚îÄ lexical.py
‚îú‚îÄ‚îÄ output\
‚îÇ   ‚îú‚îÄ‚îÄ audio\
‚îÇ   ‚îî‚îÄ‚îÄ transcripts\
‚îî‚îÄ‚îÄ tests\
    ‚îî‚îÄ‚îÄ download_and_transcribe_youtube.py
